// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: connector/v1/connector.proto

package connectorv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Connector with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Connector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Connector with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectorMultiError, or nil
// if none found.
func (m *Connector) ValidateAll() error {
	return m.validate(true)
}

func (m *Connector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_Connector_Id_Pattern.MatchString(m.GetId()) {
		err := ConnectorValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[0-9a-fA-F\\\\-]{36}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetWorkspaceId()); l < 1 || l > 32 {
		err := ConnectorValidationError{
			field:  "WorkspaceId",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Connector_WorkspaceId_Pattern.MatchString(m.GetWorkspaceId()) {
		err := ConnectorValidationError{
			field:  "WorkspaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9_-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTenantId()); l < 1 || l > 32 {
		err := ConnectorValidationError{
			field:  "TenantId",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Connector_TenantId_Pattern.MatchString(m.GetTenantId()) {
		err := ConnectorValidationError{
			field:  "TenantId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9_-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDefaultChannelId()); l < 1 || l > 100 {
		err := ConnectorValidationError{
			field:  "DefaultChannelId",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Connector_DefaultChannelId_Pattern.MatchString(m.GetDefaultChannelId()) {
		err := ConnectorValidationError{
			field:  "DefaultChannelId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9_-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetSecretVersion()) < 1 {
		err := ConnectorValidationError{
			field:  "SecretVersion",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConnectorMultiError(errors)
	}

	return nil
}

// ConnectorMultiError is an error wrapping multiple validation errors returned
// by Connector.ValidateAll() if the designated constraints aren't met.
type ConnectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorMultiError) AllErrors() []error { return m }

// ConnectorValidationError is the validation error returned by
// Connector.Validate if the designated constraints aren't met.
type ConnectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorValidationError) ErrorName() string { return "ConnectorValidationError" }

// Error satisfies the builtin error interface
func (e ConnectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorValidationError{}

var _Connector_Id_Pattern = regexp.MustCompile("^[0-9a-fA-F\\-]{36}$")

var _Connector_WorkspaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9_-]+$")

var _Connector_TenantId_Pattern = regexp.MustCompile("^[A-Za-z0-9_-]+$")

var _Connector_DefaultChannelId_Pattern = regexp.MustCompile("^[A-Za-z0-9_-]+$")

// Validate checks the field values on CreateConnectorRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConnectorRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConnectorRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConnectorRequestMultiError, or nil if none found.
func (m *CreateConnectorRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConnectorRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetWorkspaceId()); l < 1 || l > 32 {
		err := CreateConnectorRequestValidationError{
			field:  "WorkspaceId",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateConnectorRequest_WorkspaceId_Pattern.MatchString(m.GetWorkspaceId()) {
		err := CreateConnectorRequestValidationError{
			field:  "WorkspaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9_-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTenantId()); l < 1 || l > 32 {
		err := CreateConnectorRequestValidationError{
			field:  "TenantId",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateConnectorRequest_TenantId_Pattern.MatchString(m.GetTenantId()) {
		err := CreateConnectorRequestValidationError{
			field:  "TenantId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9_-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetToken()); l < 4 || l > 512 {
		err := CreateConnectorRequestValidationError{
			field:  "Token",
			reason: "value length must be between 4 and 512 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDefaultChannelName()); l < 1 || l > 100 {
		err := CreateConnectorRequestValidationError{
			field:  "DefaultChannelName",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateConnectorRequest_DefaultChannelName_Pattern.MatchString(m.GetDefaultChannelName()) {
		err := CreateConnectorRequestValidationError{
			field:  "DefaultChannelName",
			reason: "value does not match regex pattern \"^[A-Za-z0-9_-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateConnectorRequestMultiError(errors)
	}

	return nil
}

// CreateConnectorRequestMultiError is an error wrapping multiple validation
// errors returned by CreateConnectorRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateConnectorRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConnectorRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConnectorRequestMultiError) AllErrors() []error { return m }

// CreateConnectorRequestValidationError is the validation error returned by
// CreateConnectorRequest.Validate if the designated constraints aren't met.
type CreateConnectorRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConnectorRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConnectorRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConnectorRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConnectorRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConnectorRequestValidationError) ErrorName() string {
	return "CreateConnectorRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConnectorRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConnectorRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConnectorRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConnectorRequestValidationError{}

var _CreateConnectorRequest_WorkspaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9_-]+$")

var _CreateConnectorRequest_TenantId_Pattern = regexp.MustCompile("^[A-Za-z0-9_-]+$")

var _CreateConnectorRequest_DefaultChannelName_Pattern = regexp.MustCompile("^[A-Za-z0-9_-]+$")

// Validate checks the field values on CreateConnectorResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConnectorResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConnectorResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConnectorResponseMultiError, or nil if none found.
func (m *CreateConnectorResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConnectorResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConnectorResponseValidationError{
					field:  "Connector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConnectorResponseValidationError{
					field:  "Connector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConnectorResponseValidationError{
				field:  "Connector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConnectorResponseMultiError(errors)
	}

	return nil
}

// CreateConnectorResponseMultiError is an error wrapping multiple validation
// errors returned by CreateConnectorResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateConnectorResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConnectorResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConnectorResponseMultiError) AllErrors() []error { return m }

// CreateConnectorResponseValidationError is the validation error returned by
// CreateConnectorResponse.Validate if the designated constraints aren't met.
type CreateConnectorResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConnectorResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConnectorResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConnectorResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConnectorResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConnectorResponseValidationError) ErrorName() string {
	return "CreateConnectorResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConnectorResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConnectorResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConnectorResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConnectorResponseValidationError{}

// Validate checks the field values on GetConnectorRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectorRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectorRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectorRequestMultiError, or nil if none found.
func (m *GetConnectorRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectorRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetConnectorRequest_Id_Pattern.MatchString(m.GetId()) {
		err := GetConnectorRequestValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[0-9a-fA-F\\\\-]{36}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetConnectorRequestMultiError(errors)
	}

	return nil
}

// GetConnectorRequestMultiError is an error wrapping multiple validation
// errors returned by GetConnectorRequest.ValidateAll() if the designated
// constraints aren't met.
type GetConnectorRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectorRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectorRequestMultiError) AllErrors() []error { return m }

// GetConnectorRequestValidationError is the validation error returned by
// GetConnectorRequest.Validate if the designated constraints aren't met.
type GetConnectorRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectorRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectorRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectorRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectorRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectorRequestValidationError) ErrorName() string {
	return "GetConnectorRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectorRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectorRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectorRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectorRequestValidationError{}

var _GetConnectorRequest_Id_Pattern = regexp.MustCompile("^[0-9a-fA-F\\-]{36}$")

// Validate checks the field values on GetConnectorResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectorResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectorResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectorResponseMultiError, or nil if none found.
func (m *GetConnectorResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectorResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConnectorResponseValidationError{
					field:  "Connector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConnectorResponseValidationError{
					field:  "Connector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConnectorResponseValidationError{
				field:  "Connector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetConnectorResponseMultiError(errors)
	}

	return nil
}

// GetConnectorResponseMultiError is an error wrapping multiple validation
// errors returned by GetConnectorResponse.ValidateAll() if the designated
// constraints aren't met.
type GetConnectorResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectorResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectorResponseMultiError) AllErrors() []error { return m }

// GetConnectorResponseValidationError is the validation error returned by
// GetConnectorResponse.Validate if the designated constraints aren't met.
type GetConnectorResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectorResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectorResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectorResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectorResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectorResponseValidationError) ErrorName() string {
	return "GetConnectorResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectorResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectorResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectorResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectorResponseValidationError{}

// Validate checks the field values on DeleteConnectorRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteConnectorRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteConnectorRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteConnectorRequestMultiError, or nil if none found.
func (m *DeleteConnectorRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteConnectorRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeleteConnectorRequest_Id_Pattern.MatchString(m.GetId()) {
		err := DeleteConnectorRequestValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[0-9a-fA-F\\\\-]{36}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetWorkspaceId()); l < 1 || l > 32 {
		err := DeleteConnectorRequestValidationError{
			field:  "WorkspaceId",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteConnectorRequest_WorkspaceId_Pattern.MatchString(m.GetWorkspaceId()) {
		err := DeleteConnectorRequestValidationError{
			field:  "WorkspaceId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9_-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTenantId()); l < 1 || l > 32 {
		err := DeleteConnectorRequestValidationError{
			field:  "TenantId",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_DeleteConnectorRequest_TenantId_Pattern.MatchString(m.GetTenantId()) {
		err := DeleteConnectorRequestValidationError{
			field:  "TenantId",
			reason: "value does not match regex pattern \"^[A-Za-z0-9_-]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteConnectorRequestMultiError(errors)
	}

	return nil
}

// DeleteConnectorRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteConnectorRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteConnectorRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConnectorRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConnectorRequestMultiError) AllErrors() []error { return m }

// DeleteConnectorRequestValidationError is the validation error returned by
// DeleteConnectorRequest.Validate if the designated constraints aren't met.
type DeleteConnectorRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConnectorRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConnectorRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConnectorRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConnectorRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConnectorRequestValidationError) ErrorName() string {
	return "DeleteConnectorRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConnectorRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConnectorRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConnectorRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConnectorRequestValidationError{}

var _DeleteConnectorRequest_Id_Pattern = regexp.MustCompile("^[0-9a-fA-F\\-]{36}$")

var _DeleteConnectorRequest_WorkspaceId_Pattern = regexp.MustCompile("^[A-Za-z0-9_-]+$")

var _DeleteConnectorRequest_TenantId_Pattern = regexp.MustCompile("^[A-Za-z0-9_-]+$")

// Validate checks the field values on DeleteConnectorResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteConnectorResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteConnectorResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteConnectorResponseMultiError, or nil if none found.
func (m *DeleteConnectorResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteConnectorResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return DeleteConnectorResponseMultiError(errors)
	}

	return nil
}

// DeleteConnectorResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteConnectorResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteConnectorResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConnectorResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConnectorResponseMultiError) AllErrors() []error { return m }

// DeleteConnectorResponseValidationError is the validation error returned by
// DeleteConnectorResponse.Validate if the designated constraints aren't met.
type DeleteConnectorResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConnectorResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConnectorResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConnectorResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConnectorResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConnectorResponseValidationError) ErrorName() string {
	return "DeleteConnectorResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConnectorResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConnectorResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConnectorResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConnectorResponseValidationError{}

// Validate checks the field values on GetOAuthV2URLRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOAuthV2URLRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOAuthV2URLRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOAuthV2URLRequestMultiError, or nil if none found.
func (m *GetOAuthV2URLRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOAuthV2URLRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetRedirectUri()); l < 1 || l > 1024 {
		err := GetOAuthV2URLRequestValidationError{
			field:  "RedirectUri",
			reason: "value length must be between 1 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetOAuthV2URLRequestMultiError(errors)
	}

	return nil
}

// GetOAuthV2URLRequestMultiError is an error wrapping multiple validation
// errors returned by GetOAuthV2URLRequest.ValidateAll() if the designated
// constraints aren't met.
type GetOAuthV2URLRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOAuthV2URLRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOAuthV2URLRequestMultiError) AllErrors() []error { return m }

// GetOAuthV2URLRequestValidationError is the validation error returned by
// GetOAuthV2URLRequest.Validate if the designated constraints aren't met.
type GetOAuthV2URLRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOAuthV2URLRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOAuthV2URLRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOAuthV2URLRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOAuthV2URLRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOAuthV2URLRequestValidationError) ErrorName() string {
	return "GetOAuthV2URLRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOAuthV2URLRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOAuthV2URLRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOAuthV2URLRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOAuthV2URLRequestValidationError{}

// Validate checks the field values on GetOAuthV2URLResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOAuthV2URLResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOAuthV2URLResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOAuthV2URLResponseMultiError, or nil if none found.
func (m *GetOAuthV2URLResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOAuthV2URLResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if len(errors) > 0 {
		return GetOAuthV2URLResponseMultiError(errors)
	}

	return nil
}

// GetOAuthV2URLResponseMultiError is an error wrapping multiple validation
// errors returned by GetOAuthV2URLResponse.ValidateAll() if the designated
// constraints aren't met.
type GetOAuthV2URLResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOAuthV2URLResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOAuthV2URLResponseMultiError) AllErrors() []error { return m }

// GetOAuthV2URLResponseValidationError is the validation error returned by
// GetOAuthV2URLResponse.Validate if the designated constraints aren't met.
type GetOAuthV2URLResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOAuthV2URLResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOAuthV2URLResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOAuthV2URLResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOAuthV2URLResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOAuthV2URLResponseValidationError) ErrorName() string {
	return "GetOAuthV2URLResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOAuthV2URLResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOAuthV2URLResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOAuthV2URLResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOAuthV2URLResponseValidationError{}

// Validate checks the field values on ExchangeOAuthCodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExchangeOAuthCodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeOAuthCodeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExchangeOAuthCodeRequestMultiError, or nil if none found.
func (m *ExchangeOAuthCodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeOAuthCodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCode()); l < 1 || l > 512 {
		err := ExchangeOAuthCodeRequestValidationError{
			field:  "Code",
			reason: "value length must be between 1 and 512 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExchangeOAuthCodeRequestMultiError(errors)
	}

	return nil
}

// ExchangeOAuthCodeRequestMultiError is an error wrapping multiple validation
// errors returned by ExchangeOAuthCodeRequest.ValidateAll() if the designated
// constraints aren't met.
type ExchangeOAuthCodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeOAuthCodeRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeOAuthCodeRequestMultiError) AllErrors() []error { return m }

// ExchangeOAuthCodeRequestValidationError is the validation error returned by
// ExchangeOAuthCodeRequest.Validate if the designated constraints aren't met.
type ExchangeOAuthCodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeOAuthCodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeOAuthCodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeOAuthCodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeOAuthCodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeOAuthCodeRequestValidationError) ErrorName() string {
	return "ExchangeOAuthCodeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExchangeOAuthCodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeOAuthCodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeOAuthCodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeOAuthCodeRequestValidationError{}

// Validate checks the field values on ExchangeOAuthCodeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExchangeOAuthCodeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExchangeOAuthCodeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExchangeOAuthCodeResponseMultiError, or nil if none found.
func (m *ExchangeOAuthCodeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeOAuthCodeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	if len(errors) > 0 {
		return ExchangeOAuthCodeResponseMultiError(errors)
	}

	return nil
}

// ExchangeOAuthCodeResponseMultiError is an error wrapping multiple validation
// errors returned by ExchangeOAuthCodeResponse.ValidateAll() if the
// designated constraints aren't met.
type ExchangeOAuthCodeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeOAuthCodeResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeOAuthCodeResponseMultiError) AllErrors() []error { return m }

// ExchangeOAuthCodeResponseValidationError is the validation error returned by
// ExchangeOAuthCodeResponse.Validate if the designated constraints aren't met.
type ExchangeOAuthCodeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeOAuthCodeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeOAuthCodeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeOAuthCodeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeOAuthCodeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeOAuthCodeResponseValidationError) ErrorName() string {
	return "ExchangeOAuthCodeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExchangeOAuthCodeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeOAuthCodeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeOAuthCodeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeOAuthCodeResponseValidationError{}
